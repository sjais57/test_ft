import os
import uuid
import logging
from datetime import datetime, timedelta, timezone
from typing import Optional
from fastapi import FastAPI, HTTPException, Depends, Request
from fastapi.responses import JSONResponse, HTMLResponse
from fastapi.templating import Jinja2Templates
from fastapi.security import OAuth2PasswordRequestForm
from jose import jwt, JWTError
from pydantic import BaseModel
from dotenv import load_dotenv
from auth.file_auth import authenticate_file
from auth.ldap_auth import authenticate_ldap, LDAP_AVAILABLE
from utils.api_key import get_additional_claims

# Load environment
load_dotenv()
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "dev-secret-key")
JWT_ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_HOURS = int(os.getenv("ACCESS_TOKEN_EXPIRE_HOURS", 1))
REFRESH_TOKEN_EXPIRE_DAYS = int(os.getenv("REFRESH_TOKEN_EXPIRE_DAYS", 30))
AUTH_METHOD = os.getenv("AUTH_METHOD", "file")
ALWAYS_USE_BASE_CLAIMS = os.getenv("ALWAYS_USE_BASE_CLAIMS", "true").lower() == "true"

if AUTH_METHOD == "ldap" and not LDAP_AVAILABLE:
    logging.warning("LDAP unavailable, falling back to file auth.")
    AUTH_METHOD = "file"

app = FastAPI()
templates = Jinja2Templates(directory="templates")

class TokenRequest(BaseModel):
    username: str
    password: str
    api_key: Optional[str] = None
    secret: Optional[str] = None

def get_team_id_from_user(username, user_data):
    groups = user_data.get("groups", [])
    if "administrators" in groups or "admins" in groups:
        return "admin-team"
    elif "ai-team" in groups:
        return "ai-team"
    elif "ml-team" in groups:
        return "ml-team"
    return "general-users"

def create_jwt_token(identity: str, claims: dict, secret: str, expires_delta: timedelta, token_type: str):
    now = datetime.now(timezone.utc)
    payload = {
        "iat": now,
        "nbf": now,
        "jti": str(uuid.uuid4()),
        "exp": now + expires_delta,
        "sub": identity,
        "type": token_type,
        "fresh": token_type == "access",
        **claims
    }
    return jwt.encode(payload, secret, algorithm=JWT_ALGORITHM)

@app.post("/token")
async def login(data: TokenRequest):
    if not data.username or not data.password:
        raise HTTPException(status_code=400, detail="Missing username or password")

    if AUTH_METHOD == "ldap":
        authenticated, user_data = authenticate_ldap(data.username, data.password)
    else:
        authenticated, user_data = authenticate_file(data.username, data.password)

    if not authenticated:
        raise HTTPException(status_code=401, detail=user_data.get("error", "Invalid username or password"))

    user_context = {
        "user_id": data.username,
        "email": user_data.get("email", ""),
        "groups": user_data.get("groups", []),
        "roles": user_data.get("roles", []),
        "team_id": get_team_id_from_user(data.username, user_data)
    }

    if data.api_key:
        user_context["api_key_id"] = data.api_key
        claims = get_additional_claims(data.api_key, user_context)
    else:
        claims = get_additional_claims(None, user_context)

    claims = {**user_data, **claims}
    expires = timedelta(hours=claims.pop("exp_hours", ACCESS_TOKEN_EXPIRE_HOURS))

    if data.secret:
        access_token = create_jwt_token(data.username, claims, data.secret, expires, "access")
        refresh_token = create_jwt_token(data.username, claims, data.secret, timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS), "refresh")
        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "note": "Custom secret used"
        }

    access_token = create_jwt_token(data.username, claims, JWT_SECRET_KEY, expires, "access")
    refresh_token = create_jwt_token(data.username, claims, JWT_SECRET_KEY, timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS), "refresh")

    return {"access_token": access_token, "refresh_token": refresh_token}

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})
