import os
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, List
import jwt
from pydantic import BaseModel
from dotenv import load_dotenv
import getpass
import logging
from ldap3 import Server, Connection, ALL, SUBTREE
from ldap3.core.exceptions import LDAPException

# Configuration
load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# LDAP Configuration
LDAP_SERVER = os.getenv("LDAP_SERVER", "ldap://your-ldap-server")
LDAP_DOMAIN = os.getenv("LDAP_DOMAIN", "dc=example,dc=com")
LDAP_USER_SEARCH = os.getenv("LDAP_USER_SEARCH", "ou=users")
LDAP_GROUP_SEARCH = os.getenv("LDAP_GROUP_SEARCH", "ou=groups")

# JWT Configuration
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "your-secret-key-here")
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60
REFRESH_TOKEN_EXPIRE_DAYS = 30

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    user_info: Dict[str, str | List[str]]

def authenticate_ldap(username: str, password: str) -> tuple[bool, dict]:
    """Authenticate user against LDAP server and fetch user data"""
    try:
        server = Server(LDAP_SERVER, get_info=ALL)
        conn = Connection(server, user=f"cn={username},{LDAP_USER_SEARCH},{LDAP_DOMAIN}", password=password)
        
        if not conn.bind():
            return False, {"error": "Invalid credentials"}
        
        # Search for user attributes
        conn.search(
            search_base=f"{LDAP_USER_SEARCH},{LDAP_DOMAIN}",
            search_filter=f"(cn={username})",
            search_scope=SUBTREE,
            attributes=['mail', 'memberOf']
        )
        
        if not conn.entries:
            return False, {"error": "User not found"}
        
        entry = conn.entries[0]
        email = entry.mail.value if hasattr(entry, 'mail') else f"{username}@example.com"
        
        # Get groups
        groups = []
        if hasattr(entry, 'memberOf'):
            groups = [group.split(',')[0].split('=')[1] for group in entry.memberOf.values]
        
        # Get roles (simplified - in real app you might have separate role mappings)
        roles = ["user"]
        if "admin" in groups or "administrators" in groups:
            roles.append("admin")
        
        return True, {
            "email": email,
            "groups": groups,
            "roles": roles
        }
        
    except LDAPException as e:
        logger.error(f"LDAP Error: {str(e)}")
        return False, {"error": "LDAP authentication failed"}

def get_team_id(groups: List[str]) -> str:
    """Determine team ID based on LDAP groups"""
    if "admin" in groups or "administrators" in groups:
        return "admin-team"
    elif "ai-team" in groups:
        return "ai-team"
    elif "ml-team" in groups:
        return "ml-team"
    return "general-users"

def create_jwt_token(data: dict, expires_delta: timedelta) -> str:
    """Generate JWT token with expiration"""
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + expires_delta
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)

def generate_tokens_interactive() -> Optional[TokenResponse]:
    """Interactive token generation workflow"""
    print("\nLDAP JWT Token Generator")
    print("="*40)
    
    username = input("LDAP Username: ").strip()
    password = getpass.getpass("LDAP Password: ").strip()
    
    # Authenticate
    authenticated, user_data = authenticate_ldap(username, password)
    if not authenticated:
        logger.error(f"Authentication failed: {user_data.get('error')}")
        return None
    
    # Prepare claims
    team_id = get_team_id(user_data["groups"])
    token_data = {
        "sub": username,
        "user_id": username,
        "email": user_data["email"],
        "groups": user_data["groups"],
        "roles": user_data["roles"],
        "team_id": team_id
    }
    
    # Generate tokens
    access_token = create_jwt_token(
        token_data,
        timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    
    refresh_token = create_jwt_token(
        {**token_data, "token_type": "refresh"},
        timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    )
    
    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        user_info={
            "username": username,
            "email": user_data["email"],
            "groups": user_data["groups"],
            "roles": user_data["roles"],
            "team_id": team_id
        }
    )

if __name__ == "__main__":
    tokens = generate_tokens_interactive()
    
    if tokens:
        print("\nSuccess! Generated Tokens:")
        print(f"\nAccess Token:\n{tokens.access_token}")
        print(f"\nRefresh Token:\n{tokens.refresh_token}")
        
        print("\nUser Information:")
        for key, value in tokens.user_info.items():
            print(f"{key.title():<10}: {value if isinstance(value, str) else ', '.join(value)}")
        
        print("\nYou can inspect these tokens at: https://jwt.io")
        print(f"Using secret key: {JWT_SECRET_KEY}")
    else:
        print("\nToken generation failed. Please check your credentials.")
