import os
from datetime import datetime, timedelta, timezone
import jwt
import uuid
from getpass import getpass
from ldap3 import Server, Connection, ALL, NTLM
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configuration
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "dev-secret-key")
JWT_ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60
LDAP_SERVER = os.getenv("LDAP_SERVER", "your-ad-server.domain.com")
LDAP_DOMAIN = os.getenv("LDAP_DOMAIN", "DOMAIN")
LDAP_SEARCH_BASE = os.getenv("LDAP_SEARCH_BASE", "dc=domain,dc=com")

def authenticate_with_ad(username: str, password: str) -> tuple[bool, dict]:
    """Authenticate against Active Directory and get user groups"""
    try:
        server = Server(LDAP_SERVER, get_info=ALL)
        conn = Connection(
            server,
            user=f"{LDAP_DOMAIN}\\{username}",
            password=password,
            authentication=NTLM,
            auto_bind=True
        )
        
        # Search for user to get groups
        conn.search(
            search_base=LDAP_SEARCH_BASE,
            search_filter=f"(sAMAccountName={username})",
            attributes=['memberOf', 'mail']
        )
        
        if not conn.entries:
            return False, {"error": "User not found in AD"}
        
        user_entry = conn.entries[0]
        groups = []
        if 'memberOf' in user_entry:
            groups = [group.split(',')[0].split('=')[1] 
                     for group in user_entry.memberOf.values]
        
        return True, {
            "username": username,
            "email": user_entry.mail.value if 'mail' in user_entry else "",
            "groups": groups
        }
        
    except Exception as e:
        return False, {"error": str(e)}

def get_team_id_from_user(user_data: dict) -> str:
    """Determine team ID from user's AD groups"""
    groups = user_data.get("groups", [])
    if "Domain Admins" in groups or "Administrators" in groups:
        return "admin-team"
    elif "AI Team" in groups:
        return "ai-team"
    elif "ML Team" in groups:
        return "ml-team"
    return "general-users"

def generate_jwt_token(user_data: dict) -> str:
    """Generate JWT token with user claims"""
    team_id = get_team_id_from_user(user_data)
    
    payload = {
        "sub": user_data["username"],
        "iat": datetime.now(timezone.utc),
        "exp": datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES),
        "jti": str(uuid.uuid4()),
        "username": user_data["username"],
        "email": user_data.get("email", ""),
        "groups": user_data.get("groups", []),
        "team_id": team_id
    }
    return jwt.encode(payload, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)

def main():
    print("=== AD Authentication JWT Generator ===")
    
    while True:
        username = input("AD Username: ").strip()
        if not username:
            print("Username cannot be empty. Try again.")
            continue
            
        password = getpass("AD Password: ").strip()
        if not password:
            print("Password cannot be empty. Try again.")
            continue
        
        authenticated, user_data = authenticate_with_ad(username, password)
        
        if authenticated:
            token = generate_jwt_token(user_data)
            print("\n=== Your JWT Token ===")
            print(token)
            print("\nToken Contents:")
            decoded = jwt.decode(token, options={"verify_signature": False})
            for k, v in decoded.items():
                print(f"{k}: {v}")
            break
        else:
            print(f"Authentication failed: {user_data.get('error', 'Unknown error')}")
            print("Please try again.\n")

if __name__ == "__main__":
    main()


==========================================
from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.security import OAuth2PasswordRequestForm
from pydantic import BaseModel
from typing import Optional
import jwt
import datetime
import ldap3

app = FastAPI()

SECRET_KEY = "verySecretValue"
ALGORITHM = "HS256"

LDAP_SERVER = "ldap://192.168.100.11"
LDAP_DOMAIN = "example.com"

class Token(BaseModel):
    access_token: str
    token_type: str

def authenticate_user(username: str, password: str):
    server = ldap3.Server(LDAP_SERVER)
    user_dn = f"{username}@{LDAP_DOMAIN}"
    try:
        conn = ldap3.Connection(server, user=user_dn, password=password, auto_bind=True)
        return True
    except ldap3.core.exceptions.LDAPBindError:
        return False

@app.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends()):
    username = form_data.username
    password = form_data.password

    if not authenticate_user(username, password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )

    payload = {
        "sub": username,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=30)
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

    return {"access_token": token, "token_type": "bearer"}

@app.get("/decode")
def decode_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return {"token_data": payload}
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token has expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")


====================================
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from datetime import datetime, timedelta
import jwt
from ldap3 import Server, Connection, ALL, NTLM
from fastapi.security import OAuth2PasswordRequestForm
from typing import Dict

# Configuration
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

LDAP_SERVER = "ldap://your.ldap.server"
LDAP_USER_DN_FORMAT = "yourdomain\\{username}"  # e.g., "CORP\\{username}"

# FastAPI app
app = FastAPI()


# Pydantic models
class TokenRequest(BaseModel):
    username: str
    password: str


class DecodeRequest(BaseModel):
    token: str


# Token creation function
def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


# LDAP authentication function
def authenticate_ldap_user(username: str, password: str):
    user_dn = LDAP_USER_DN_FORMAT.format(username=username)
    server = Server(LDAP_SERVER, get_info=ALL)

    try:
        conn = Connection(server, user=user_dn, password=password, authentication=NTLM, auto_bind=True)
        return True
    except Exception as e:
        return False


# JWT Token endpoint
@app.post("/token")
def login_for_access_token(form_data: TokenRequest):
    if not authenticate_ldap_user(form_data.username, form_data.password):
        raise HTTPException(status_code=401, detail="Invalid LDAP credentials")
    
    token_data = {
        "sub": form_data.username,
        "time": datetime.utcnow().isoformat()
    }
    token = create_access_token(data=token_data)
    return {"access_token": token, "token_type": "bearer"}


# Token decode endpoint
@app.post("/decode")
def decode_jwt_token(data: DecodeRequest):
    try:
        decoded_token = jwt.decode(data.token, SECRET_KEY, algorithms=[ALGORITHM])
        return {"decoded": decoded_token}
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")
